ADDSP3 R0 0x0000
ADDSP3 R0 0x0000
NOP

;保存用户程序寄存器的地址 
;0xBF10  0xBF11 BF12 0xBF13 BF14 0xBF15
; R0    R1   R2   R3   R4   R5  

B START
NOP

DELINT:   ;中断处理程序
	NOP
	NOP
	NOP
	;保存用户程序现场
	LI R6 0xBF
	SLL R6 R6 0x0000
	ADDIU R6 0x10					;R6=0xBF10
	SW R6 R0 0x0000
	SW R6 R1 0x0001
	SW R6 R2 0x0002
	

	

	
	;R1=中断号
	LW_SP R1 0x0000
	ADDSP 0x0001
	LI R0 0x00FF
	AND R1 R0
	
	;R2=应用程序的pc
	LW_SP R2 0x0000
	ADDSP 0x0001
	
	;保存r3
	ADDSP 0xFFFF
	SW_SP R3 0x0000


	
	;保存用户程序返回地址
	ADDSP 0xFFFF
	SW_SP R7 0x0000
	
	;提示终端，进入中断处理
	LI R3 0x000F
	MFPC R7 
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00
	SW R6 R3 0x0000
	NOP
	;输出中断号
	MFPC R7 
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00 
	SW R6 R1 0x0000
	NOP
	
	;提示终端，中断处理结束
	LI R3 0x000F
	MFPC R7 
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00 
	SW R6 R3 0x0000
	NOP
	
	;R6保存返回地址
	ADDIU3 R2 R6 0x0000
	
	;用r3=IH（高位变成1）
	MFIH R3
	LI R0 0x0080
	SLL R0 R0 0x000
	OR R3 R0
	
	;恢复现场
	LI R7 0xBF
	SLL R7 R7 0x0000
	ADDIU R7 0x10					;R7=0xBF10
	LW R7 R0 0x0000
	LW R7 R1 0x0001
	LW R7 R2 0x0002
	
	;r7=用户程序返回地址
	LW_SP R7 0x0000
	
	ADDSP 0x0001
	ADDSP 0x0001
	NOP
	MTIH R3;
	JR R6
	LW_SP R3 0x00FF
	
	NOP	


;init  0x8251
START:
	;初始化IH寄存器，最高位为1时，允许中断，为0时不允许。初始化为0，kernel不允许中断
	LI R0 0x07
	MTIH R0
	;初始化栈地址
	LI R0 0x00BF 
	SLL R0 R0 0x0000
	ADDIU R0 0x10					;R0=0xBF10 
	MTSP R0
	NOP
	
	;用户寄存器值初始化
	LI R6 0x00BF 
	SLL R6 R6 0x0000
	ADDIU R6 0x10					;R6=0xBF10 
	LI R0 0x0000
	SW R6 R0 0x0000
	SW R6 R0 0x0001
	SW R6 R0 0x0002
	SW R6 R0 0x0003
	SW R6 R0 0x0004
	SW R6 R0 0x0005
		
	;WELCOME
	MFPC R7 
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LI R0 0x004F
	SW R6 R0 0x0000
	NOP
	
	MFPC R7 
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LI R0 0x004B
	SW R6 R0 0x0000
	NOP
	
	MFPC R7 
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LI R0 0x000A
	SW R6 R0 0x0000
	NOP
	
	MFPC R7 
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
9e	LI R0 0x000D
9f	SW R6 R0 0x0000
a0	NOP
	

	

	

	
BEGIN:          ;检测命令
	;接收字符，保存到r1
a1	MFPC R7
a2	ADDIU R7 0x0003	
a3	NOP	
a4	B TESTR	
a5	NOP
a6	LI R6 0x00BF 
a7	SLL R6 R6 0x0000 
a8	LW R6 R1 0x0000
a9	LI R6 0x00ff 
aa  AND R1 R6 
ab	NOP	
	

	;检测是否为R命令		
ac	LI R0 0x0052
ad	CMP R0 R1
ae	BTEQZ SHOWREGS	
af	NOP	
	;检测是否为D命令
b0	LI R0 0x0044
b1	CMP R0 R1
b2	BTEQZ SHOWMEM
b3	NOP	
	
	;检测是否为A命令
b4	LI R0 0x0041
b5	CMP R0 R1
b6	BTEQZ GOTOASM
b7	NOP	
	
	;检测是否为U命令
	LI R0 0x0055
	CMP R0 R1
	BTEQZ GOTOUASM
	NOP	
	;检测是否为G命令
	LI R0 0x0047
	CMP R0 R1
	BTEQZ GOTOCOMPILE
	NOP		
	
	B BEGIN
	NOP

;各处理块的入口
GOTOUASM:
	NOP
	B UASM
	NOP
GOTOASM:
c5	NOP
c6	B ASM
c7	NOP
	
GOTOCOMPILE:
	NOP
	B COMPILE
	NOP
  
	
;测试8251是否能写
TESTW:	
	NOP	 		
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	ADDIU R6 0x0001 
	LW R6 R0 0x0000 
	LI R6 0x0001 
	AND R0 R6 
	BEQZ R0 TESTW     ;BF01&1=0 则等待	
	NOP		
d4	JR R7
d5	NOP 
	

	
;测试8251是否能读
TESTR:	
d6	NOP	
d7	LI R6 0x00BF 
d8	SLL R6 R6 0x0000 
d9	ADDIU R6 0x0001 
da	LW R6 R0 0x0000 
db	LI R6 0x0002
dc	AND R0 R6 
dd	BEQZ R0 TESTR   ;BF01&2=0  则等待	
de	NOP	
df	JR R7
e0	NOP 		
	
	
SHOWREGS:    ;R命令，打印R0-R5
	LI R1 0x0006  ;R1递减  
	LI R2 0x0006   ;R2不变
	
LOOP:
	LI R0  0x00BF
	SLL R0 R0 0x0000
	ADDIU R0 0x0010
	SUBU R2 R1 R3   ;R2=0,1,2,3
	ADDU R0 R3 R0   ;R0=BF10...
	LW R0 R3 0x0000    ;R3=用户程序的 R0,R1,R2	

	;发送低八位
	MFPC R7
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=BF00	
	SW R6 R3 0x0000	
	;发送高八位
	SRA R3 R3 0x0000
	MFPC R7
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R3 0x0000	
	
	ADDIU R1 0xFFFF
	NOP
	BNEZ R1 LOOP
	NOP	
	B BEGIN
	NOP
	

	
	

	
	
	
SHOWMEM:  ;查看内存	
;D读取地址低位到r5
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000	
	LI R6 0x00FF
	AND R5 R6
	NOP	
	
	;读取地址高位到r1
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R1 0x0000
	LI R6 0x00FF
	AND R1 R6
	NOP	
	
	
	
	;R1存储地址
	SLL R1 R1 0x0000
	OR R1 R5
	
	;读取显示次数低位到R5
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000
	LI R6 0x00FF
	AND R5 R6
	NOP	
	;读取显示次数高位到R2
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R2 0x0000
	LI R6 0x00FF
	AND R2 R6
	NOP	
	;R2保存内存个数
	SLL R2 R2 0x0000
	OR R2 R5

	
		;循环发出	
	
MEMLOOP:		
	
	LW R1 R3 0x0000    ;R3为内存数据	

	;发送低八位
	MFPC R7
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R3 0x0000	
	;发送高八位

	SRA R3 R3 0x0000
	MFPC R7
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R3 0x0000	
	
	ADDIU R1 0x0001   ;R1=地址加加加
	ADDIU R2 0xFFFF
	NOP
	BNEZ R2 MEMLOOP
	NOP	

147	B BEGIN
148	NOP		


 ;汇编	
ASM:  
	;A命令读取地址低位到r5
149	MFPC R7
14a	ADDIU R7 0x0003	
14b	NOP	
14c	B TESTR	
14d	NOP
14e	LI R6 0x00BF 
14f	SLL R6 R6 0x0000 
150	LW R6 R5 0x0000
151	LI R6 0x00FF
152	AND R5 R6
153	NOP	
	;读取地址高位到r1
154	MFPC R7
155	ADDIU R7 0x0003	
156	NOP	
157	B TESTR	
158	NOP
159	LI R6 0x00BF 
15a	SLL R6 R6 0x0000 
15b	LW R6 R1 0x0000
15c	LI R6 0x00FF
15d	AND R1 R6
15e	NOP	
	
	;R1存储地址
15f	SLL R1 R1 0x0000
160	OR R1 R5
	
	
	
	
	;检测地址是否合法
161	LI R0 0x0000
162	CMP R0 R1      
163  BTEQZ GOTOBEGIN
164	NOP	
	
 
	;读取数据低位到R5
165	MFPC R7
166	ADDIU R7 0x0003	
167	NOP	
168	B TESTR	
169	NOP
16a	LI R6 0x00BF 
16b	SLL R6 R6 0x0000 
16c	LW R6 R5 0x0000
16d	LI R6 0x00FF
16e	AND R5 R6
16f	NOP	
	

	;读取数据高位到R2
170	MFPC R7
171	ADDIU R7 0x0003	
172	NOP	
173	B TESTR	
174	NOP
175	LI R6 0x00BF 
176	SLL R6 R6 0x0000 
177	LW R6 R2 0x0000
178	LI R6 0x00FF
179	AND R2 R6
17a	NOP	
	;R2保存数据
17b	SLL R2 R2 0x0000
17c	OR R2 R5
			
17d	SW R1 R2 0x0000	
17e	NOP
	
17f	B ASM
180	NOP
	
GOTOBEGIN:
181	NOP
182	B BEGIN
183	NOP
	
	
	
	
;反汇编：将需要反汇编的地址处的值发给终端处理	
UASM:
;读取地址低位到r5
184	MFPC R7
185	ADDIU R7 0x0003	
186	NOP	
187	B TESTR	
188	NOP
189	LI R6 0x00BF 
18a	SLL R6 R6 0x0000 
18b	LW R6 R5 0x0000
18c	LI R6 0x00FF
18d	AND R5 R6
18e	NOP	
	;读取地址高位到r1
18f	MFPC R7
190	ADDIU R7 0x0003	
191	NOP	
192	B TESTR	
193	NOP
194	LI R6 0x00BF 
195	SLL R6 R6 0x0000 
196	LW R6 R1 0x0000
197	LI R6 0x00FF
198	AND R1 R6
199	NOP	
	
	
	
	;R1存储地址
19a	SLL R1 R1 0x0000
19b	OR R1 R5
	
	;读取显示次数低位到R5
19c	MFPC R7
19d	ADDIU R7 0x0003	
19e	NOP	
19f	B TESTR	
1a0	NOP
1a1	LI R6 0x00BF 
1a2	SLL R6 R6 0x0000 
1a3	LW R6 R5 0x0000
1a4	LI R6 0x00FF
1a5	AND R5 R6
1a6	NOP	
	;读取显示次数高位到R2
1a7	MFPC R7
1a8	ADDIU R7 0x0003	
1a9	NOP	
1aa	B TESTR	
1ab	NOP
1ac	LI R6 0x00BF 
1ad	SLL R6 R6 0x0000 
1ae	LW R6 R2 0x0000
1af	LI R6 0x00FF
1b0	AND R2 R6
1b1	NOP	
	;R2保存内存个数
1b2	SLL R2 R2 0x0000
1b3	OR R2 R5

	
		;循环发出	
	
UASMLOOP:		
	
1b4	LW R1 R3 0x0000    ;R3为内存数据	

	;发送低八位
1b5	MFPC R7
1b6	ADDIU R7 0x0003	
1b7	NOP
1b8	B TESTW	
1b9	NOP	
1ba	LI R6 0x00BF 
1bb	SLL R6 R6 0x0000 ;R6=0xBF00	
1bc	SW R6 R3 0x0000	
	;发送高八位

1bd	SRA R3 R3 0x0000
1be	MFPC R7
1bf	ADDIU R7 0x0003	
1c0	NOP
1c1	B TESTW	
1c2	NOP	
1c3	LI R6 0x00BF 
1c4	SLL R6 R6 0x0000 ;R6=0xBF00	
1c5	SW R6 R3 0x0000	
	
1c6	ADDIU R1 0x0001   ;R1=地址加加加
1c7	ADDIU R2 0xFFFF
1c8	NOP
1c9	BNEZ R2 UASMLOOP
1ca	NOP	

1cb	B BEGIN
1cc	NOP			
	
;连续执行
COMPILE:
	;读取地址低位到R5
1cd	MFPC R7
1ce	ADDIU R7 0x0003	
1cf	NOP	
1d0	B TESTR	
1d1	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000
	LI R6 0x00FF
	AND R5 R6
	NOP	
	;读取内存高位到R2
	MFPC R7
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R2 0x0000
	LI R6 0x00FF
	AND R2 R6
	NOP	
	;R2保存内存地址  传给r6
	SLL R2 R2 0x0000
	OR R2 R5
	ADDIU3 R2 R6 0x0000
	
	
	LI R7 0x00BF
	SLL R7 R7 0x0000
	ADDIU R7 0x0010
	
	LW R7 R5 0x0005
	ADDSP 0xFFFF
	SW_SP R5 0x0000
	
	
	;中断保存在R5中
	MFIH R5
	LI R1 0x0080
	SLL R1 R1 0x000
	OR R5 R1
	
	
	
	;恢复现场
	LW R7 R0 0x0000
	LW R7 R1 0x0001
	LW R7 R2 0x0002
	LW R7 R3 0x0003
	LW R7 R4 0x0004
	
	
	
	MFPC R7
	ADDIU R7 0x0004
	MTIH R5    ;IH高位赋1	
	JR R6
	LW_SP R5 0x0000  ;R5恢复现场
	
	;用户程序执行完毕，返回kernel，保存现场
	NOP
	NOP
	ADDSP 0x0001
	LI R7 0x00BF
	SLL R7 R7 0x0000
	ADDIU R7 0x0010
	
	SW R7 R0 0x0000
	SW R7 R1 0x0001
	SW R7 R2 0x0002
	SW R7 R3 0x0003
	SW R7 R4 0x0004
	SW R7 R5 0x0005
	
	;IH高位赋0
	MFIH R0
	LI R1 0x007F
	SLL R1 R1 0x0000
	LI R2 0x00FF
	OR R1 R2	
	AND R0 R1
	MTIH R0
	
	;给终端发送结束用户程序提示
	LI R1 0x0007
	MFPC R7
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R1 0x0000		
	B BEGIN
	NOP	
		
	
	




	